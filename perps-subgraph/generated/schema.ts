// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  TypedMap,
  Entity,
  Value,
  ValueKind,
  store,
  Bytes,
  BigInt,
  BigDecimal
} from "@graphprotocol/graph-ts";

export class PositionLiquidated extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save PositionLiquidated entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type PositionLiquidated must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("PositionLiquidated", id.toString(), this);
    }
  }

  static load(id: string): PositionLiquidated | null {
    return changetype<PositionLiquidated | null>(
      store.get("PositionLiquidated", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get account(): Bytes {
    let value = this.get("account");
    return value!.toBytes();
  }

  set account(value: Bytes) {
    this.set("account", Value.fromBytes(value));
  }

  get liquidator(): Bytes {
    let value = this.get("liquidator");
    return value!.toBytes();
  }

  set liquidator(value: Bytes) {
    this.set("liquidator", Value.fromBytes(value));
  }

  get size(): BigDecimal {
    let value = this.get("size");
    return value!.toBigDecimal();
  }

  set size(value: BigDecimal) {
    this.set("size", Value.fromBigDecimal(value));
  }

  get price(): BigDecimal {
    let value = this.get("price");
    return value!.toBigDecimal();
  }

  set price(value: BigDecimal) {
    this.set("price", Value.fromBigDecimal(value));
  }

  get fee(): BigDecimal {
    let value = this.get("fee");
    return value!.toBigDecimal();
  }

  set fee(value: BigDecimal) {
    this.set("fee", Value.fromBigDecimal(value));
  }

  get block(): BigInt {
    let value = this.get("block");
    return value!.toBigInt();
  }

  set block(value: BigInt) {
    this.set("block", Value.fromBigInt(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    return value!.toBigInt();
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }
}

export class Trader extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Trader entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Trader must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Trader", id.toString(), this);
    }
  }

  static load(id: string): Trader | null {
    return changetype<Trader | null>(store.get("Trader", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get totalLiquidations(): BigInt {
    let value = this.get("totalLiquidations");
    return value!.toBigInt();
  }

  set totalLiquidations(value: BigInt) {
    this.set("totalLiquidations", Value.fromBigInt(value));
  }

  get totalMarginLiquidated(): BigDecimal {
    let value = this.get("totalMarginLiquidated");
    return value!.toBigDecimal();
  }

  set totalMarginLiquidated(value: BigDecimal) {
    this.set("totalMarginLiquidated", Value.fromBigDecimal(value));
  }

  get tradeCount(): BigInt {
    let value = this.get("tradeCount");
    return value!.toBigInt();
  }

  set tradeCount(value: BigInt) {
    this.set("tradeCount", Value.fromBigInt(value));
  }

  get feesPaidToSynthetix(): BigDecimal {
    let value = this.get("feesPaidToSynthetix");
    return value!.toBigDecimal();
  }

  set feesPaidToSynthetix(value: BigDecimal) {
    this.set("feesPaidToSynthetix", Value.fromBigDecimal(value));
  }
}

export class Synthetix extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Synthetix entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Synthetix must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Synthetix", id.toString(), this);
    }
  }

  static load(id: string): Synthetix | null {
    return changetype<Synthetix | null>(store.get("Synthetix", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get feesGeneratedByLiquidations(): BigDecimal {
    let value = this.get("feesGeneratedByLiquidations");
    return value!.toBigDecimal();
  }

  set feesGeneratedByLiquidations(value: BigDecimal) {
    this.set("feesGeneratedByLiquidations", Value.fromBigDecimal(value));
  }
}

export class FuturesPosition extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save FuturesPosition entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type FuturesPosition must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("FuturesPosition", id.toString(), this);
    }
  }

  static load(id: string): FuturesPosition | null {
    return changetype<FuturesPosition | null>(store.get("FuturesPosition", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get lastTxHash(): Bytes {
    let value = this.get("lastTxHash");
    return value!.toBytes();
  }

  set lastTxHash(value: Bytes) {
    this.set("lastTxHash", Value.fromBytes(value));
  }

  get openTimestamp(): BigInt {
    let value = this.get("openTimestamp");
    return value!.toBigInt();
  }

  set openTimestamp(value: BigInt) {
    this.set("openTimestamp", Value.fromBigInt(value));
  }

  get closeTimestamp(): BigInt | null {
    let value = this.get("closeTimestamp");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigInt();
    }
  }

  set closeTimestamp(value: BigInt | null) {
    if (!value) {
      this.unset("closeTimestamp");
    } else {
      this.set("closeTimestamp", Value.fromBigInt(<BigInt>value));
    }
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    return value!.toBigInt();
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get block(): BigInt {
    let value = this.get("block");
    return value!.toBigInt();
  }

  set block(value: BigInt) {
    this.set("block", Value.fromBigInt(value));
  }

  get market(): Bytes {
    let value = this.get("market");
    return value!.toBytes();
  }

  set market(value: Bytes) {
    this.set("market", Value.fromBytes(value));
  }

  get asset(): Bytes {
    let value = this.get("asset");
    return value!.toBytes();
  }

  set asset(value: Bytes) {
    this.set("asset", Value.fromBytes(value));
  }

  get marketKey(): Bytes {
    let value = this.get("marketKey");
    return value!.toBytes();
  }

  set marketKey(value: Bytes) {
    this.set("marketKey", Value.fromBytes(value));
  }

  get isOpen(): boolean {
    let value = this.get("isOpen");
    return value!.toBoolean();
  }

  set isOpen(value: boolean) {
    this.set("isOpen", Value.fromBoolean(value));
  }

  get isLiquidated(): boolean {
    let value = this.get("isLiquidated");
    return value!.toBoolean();
  }

  set isLiquidated(value: boolean) {
    this.set("isLiquidated", Value.fromBoolean(value));
  }

  get totalVolume(): BigInt {
    let value = this.get("totalVolume");
    return value!.toBigInt();
  }

  set totalVolume(value: BigInt) {
    this.set("totalVolume", Value.fromBigInt(value));
  }

  get size(): BigInt {
    let value = this.get("size");
    return value!.toBigInt();
  }

  set size(value: BigInt) {
    this.set("size", Value.fromBigInt(value));
  }

  get initialMargin(): BigInt {
    let value = this.get("initialMargin");
    return value!.toBigInt();
  }

  set initialMargin(value: BigInt) {
    this.set("initialMargin", Value.fromBigInt(value));
  }

  get margin(): BigInt {
    let value = this.get("margin");
    return value!.toBigInt();
  }

  set margin(value: BigInt) {
    this.set("margin", Value.fromBigInt(value));
  }

  get pnl(): BigInt {
    let value = this.get("pnl");
    return value!.toBigInt();
  }

  set pnl(value: BigInt) {
    this.set("pnl", Value.fromBigInt(value));
  }

  get feesPaid(): BigInt {
    let value = this.get("feesPaid");
    return value!.toBigInt();
  }

  set feesPaid(value: BigInt) {
    this.set("feesPaid", Value.fromBigInt(value));
  }

  get netFunding(): BigInt {
    let value = this.get("netFunding");
    return value!.toBigInt();
  }

  set netFunding(value: BigInt) {
    this.set("netFunding", Value.fromBigInt(value));
  }

  get pnlWithFeesPaid(): BigInt {
    let value = this.get("pnlWithFeesPaid");
    return value!.toBigInt();
  }

  set pnlWithFeesPaid(value: BigInt) {
    this.set("pnlWithFeesPaid", Value.fromBigInt(value));
  }

  get netTransfers(): BigInt {
    let value = this.get("netTransfers");
    return value!.toBigInt();
  }

  set netTransfers(value: BigInt) {
    this.set("netTransfers", Value.fromBigInt(value));
  }

  get totalDeposits(): BigInt {
    let value = this.get("totalDeposits");
    return value!.toBigInt();
  }

  set totalDeposits(value: BigInt) {
    this.set("totalDeposits", Value.fromBigInt(value));
  }

  get entryPrice(): BigInt {
    let value = this.get("entryPrice");
    return value!.toBigInt();
  }

  set entryPrice(value: BigInt) {
    this.set("entryPrice", Value.fromBigInt(value));
  }

  get avgEntryPrice(): BigInt {
    let value = this.get("avgEntryPrice");
    return value!.toBigInt();
  }

  set avgEntryPrice(value: BigInt) {
    this.set("avgEntryPrice", Value.fromBigInt(value));
  }

  get lastPrice(): BigInt {
    let value = this.get("lastPrice");
    return value!.toBigInt();
  }

  set lastPrice(value: BigInt) {
    this.set("lastPrice", Value.fromBigInt(value));
  }

  get exitPrice(): BigInt | null {
    let value = this.get("exitPrice");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigInt();
    }
  }

  set exitPrice(value: BigInt | null) {
    if (!value) {
      this.unset("exitPrice");
    } else {
      this.set("exitPrice", Value.fromBigInt(<BigInt>value));
    }
  }
}

export class FuturesMarket extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save FuturesMarket entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type FuturesMarket must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("FuturesMarket", id.toString(), this);
    }
  }

  static load(id: string): FuturesMarket | null {
    return changetype<FuturesMarket | null>(store.get("FuturesMarket", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get asset(): Bytes {
    let value = this.get("asset");
    return value!.toBytes();
  }

  set asset(value: Bytes) {
    this.set("asset", Value.fromBytes(value));
  }

  get marketKey(): Bytes {
    let value = this.get("marketKey");
    return value!.toBytes();
  }

  set marketKey(value: Bytes) {
    this.set("marketKey", Value.fromBytes(value));
  }
}
